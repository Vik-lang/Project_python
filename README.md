ФИО: Соромотина Виктория 

Группа: ИТ-6

Вариант № 7

Постановка задачи: 

		Игра в «пьяницу». В игре в «пьяницу» карточная колода раздаётся поровну 
		двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта 
		старше, забирает себе обе вскрытые карты, которые кладутся под низ его 
		колоды. Тот, кто остаётся без карт – проигрывает. Для простоты будем 
		считать, что все карты различны по номиналу, а также, что самая младшая 
		карта побеждает самую старшую карту ("шестерка берет туза"). Игрок, 
		который забирает себе карты, сначала кладёт под низ своей колоды карту 
		первого игрока, затем карту второго игрока (то есть карта второго игрока 
		оказывается внизу колоды). Напишите программу, которая моделирует игру в 
		пьяницу и определяет, кто выигрывает. 
		В игре участвует 10 карт, имеющих значения от 0 до 9, большая карта 
		побеждает меньшую, карта со значением 0 побеждает карту 9. 
		Входные данные Программа получает на вход две строки: первая строка 
		содержит 5 чисел, разделённых пробелами—номера карт первого игрока, 
		вторая – аналогично 5 карт второго игрока. Карты перечислены сверху вниз, 
		то есть каждая строка начинается с той карты, которая будет открыта первой. 
		Выходные данные. Программа должна определить, кто выигрывает при 
		данной раздаче, и вывести слово first или second, после чего вывести 
		количество ходов, сделанных до выигрыша. Если на протяжении  ходов 
		игра не заканчивается, программа должна вывести слово botva. 
		Примеры входные данные 1 3 5 7 9 2 4 6 8 0 выходные данные second 5.
  

Структура данных: 

		Двусторонняя очередь на основе простого массива.
  

Пояснение:

		По условию задачи придется работать с началом и концом колоды,
		удалять и возвращать карту с начала колоды (игрок вытягивает карту),
		добавлять 2 карты в конец колоды (игрок, который победил, забирает 2 карты себе).
		Для этого была выбрана двусторонняя очередь на основе простого массива.
  

АЛГОРИТМ: 

1. Пользователь вводит номера 5 карт сначала для 1 игрока, затем для 2 игрока.

2. 2 ввода преобразуем в 2 списка строк. 

3. Запускаются 2 функции (Proverka1,Proverka2) для проверки ввода (2 списков):

Проверка символов в списке строк, которые должны включать в себя только цифры,
для этого создан вспомогательный список spis_numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
а также проверка длины:

	i = 4
	spis1 = проверяемый список строк [‘1’, ‘1’, ‘1’, ‘1’, ‘1’]

	Пока 0 <= i <= 4:

		Если (длина списка не равна 5) ИЛИ  spis1[i] не входит в spis_numbers:

 			spis1 = ввод()
			i = 5  # снова для проверки ввода 
		i = i - 1


2-ой список проверяется аналогично.


4. Преобразовываем 2 списка строк в список целых чисел.
   
		p1_cards = list(map(int, p1_input))

		p2_cards = list(map(int, p2_input))


5. Создаем одновременно объекты класса Game и объекты класса ArrayDeque, в качестве аргументов передаём списки целых чисел.

   
		class Game:

    		"""Класс, представляющий игру"""
   
    			def __init__(self, p1_cards, p2_cards):
   
        				self.player1 = ArrayDeque(p1_cards)
   
        				self.player2 = ArrayDeque(p2_cards)
   

			class ArrayDeque:

    				def __init__(self, card):
   
        					self.data = card
   

6. Запускаем игру при помощи метода play класса Game:
        
   Метод play. Количество итераций цикла for = максимальному количеству раундов, по окончанию цикла выводим слово
   botva по условию задачи, если никто не выиграл.
   
   
		max_rounds = 10**6

		for round_num in range(1, max_rounds + 1):

  			Тело цикла
   
		return "botva"



7. Метод play. В теле цикла стоит два условия: если у первого игрока колода пуста второй выигрывает, если у второго пуста, то первый выигрывает.
 
   Проверка пустоты с помощью метода has_cards класса ArrayDeque, возвращает true или false, используется bool() — логический тип данных.
   
   

		if not self.player1.has_cards(): # если колода 1 игрока пуста

    			return f"second {round_num - 1}" # объявляем 2 игрока победителем
   
		if not self.player2.has_cards(): # аналогично со вторым игроком

    			return f"first {round_num - 1}"

   

		class ArrayDeque:

    			def has_cards(self):
   
       		 	"""метод has_cards определяет есть ли у игрока карты в колоде """
   
       		 		return bool(self.data)
   


8. Метод play. Игрок вытягивает карту. С помощью метода draw_card класса ArrayDeque ( pop[0] - из начала очереди удаляем и возвращаем «карту»).
   
   

		card1 = self.player1.draw_card() # 1 игрок вытягивает карту

		card2 = self.player2.draw_card() # 2 игрок вытягивает карту


		class ArrayDeque:

			def draw_card(self):

   				return self.data.pop(0)


      

9. Метод play. Карты игроков сравниваются c помощью метода card1_wins класса Game, если у первого больше карта, он забирает 2 карты себе,  но карта второго не равна 0, и карта первого не равна 9, иначе забирает карты второй. Карты добавляем в колоду победителю с помощью метода add_cards класса ArrayDeque (добавляем в конец очереди сначала 1 карту, затем карту 2 игрока).

    
		if self.card1_wins(card1, card2): # проверка на выигрыш 1 игрока

     			self.player1.add_cards(card1) # добавляем сначала 1 карту
      
    			self.player1.add_cards(card2) # затем карту 2 игрока 
     
		else:

    			self.player2.add_cards(card1) # иначе добавляем 2 карты 2 игроку
     
      			self.player2.add_cards(card2)

       

		def card1_wins(): # метод класса Game, сравнение карт

 			 return (c1 == 0 and c2 == 9) or (c1 > c2 and not (c1 == 9 and c2 == 0))

  

		class ArrayDeque:

			def add_cards(): # метод для добавления 2 карт победителю
 
    				self.data.append(value) 

      


10. Цикл запускается заново. 

Обработка исключений:

		Ошибка может возникнуть только при неправильном вводе.
		Для проверки ввода сделаны 2 отдельные функции, не входящие в классы Game и ArrayDeque.

Пояснение: 

		Для создания объектов класса Game и класса ArrayDeque, мы передаем в качестве
		аргументов правильные списки целых чисел.
		"Правильные" списки означет, что они удовлетворяют всем условиям задачи.
		Именно поэтому перед передачей мы проверяем списки с помощью отдельных функций
		и преобразовываем их в списки целых чисел в основном коде. 







